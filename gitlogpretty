#!/usr/bin/perl
# git log pretty formatting, one commit per line
#
# Usage: gitlogpretty [options] [git options]
#             --myselect    select branch to display
#             --remote      show remote branches
#             --all         git log --all + show remote branches

my $author_max = 15;        # max author length
my $extra = "";             # extra git options
my $hide_remote = 1;        # hide remote branches
my $width = 59;             # formatting


# cmdline options
for (; @ARGV; shift(@ARGV)) {
    if ($ARGV[0] eq "--myselect" ) {
	my $cmd = 'myselect $(git branch | sed -e "s/\*//")';
	$extra .= " " . `bash -c '$cmd' `;
	($extra) || exit 0;
	next;
    }

    if ($ARGV[0] eq "--remote")  {  $hide_remote = 0; next;  }
    if ($ARGV[0] eq "--all")     {  $hide_remote = 0; $width = 79; $extra .= " --all"; next;  }
    
    last;   # Unrecognized options, pass to git
}


# String length without ansi color codes
sub real_length
{
    my ($s) = @_;
    $s =~ s/\e\[[^m]*m//g;
    return length($s);
}


# Hide remote branches if needed 
# Display branches and tags as "(branches) <tags>"
sub format_branches
{ 
    my ($branches) = @_;
    my @branches; my @tags;

    # Split tags and branches
    $branches =~ s|^ \((.*)\)|$1|;   # remove surrounding ()
    foreach my $b (split(/, /, $branches))  {
        if ($b =~ m/^tag: (.*)/)  {  push(@tags, $1);  }
        else                      {  push(@branches, $b);  }
    }

    # Hide remote/HEAD
    @branches = grep(!/\/HEAD/, @branches);

    # Hide remote branches
    if ($hide_remote)  {  @branches = grep(!/\//, @branches);  }

    $branches = "";
    if (@branches) { $branches =  sprintf(" (%s)", join(", ", @branches)); }
    if (@tags)     { $branches .= sprintf(" <%s>", join(", ", @tags)); }
    return $branches;
}


######################################################################################################
# Styles
# Note: '###' = field separator for us

# Show colored ascii-art for branches ?
my $opts = "--color";


# No colors
#my $format = "[%an] %h %ad% ###%d### %s";

# Italian style
#my $format = "[%an] %C(red)%h%Creset %C(green)%ad%Creset %C(yellow)###%d###%Creset %s";

# Lemon style
#my $format = "%C(yellow)[%an]%Creset %C(white)%h%Creset %C(white)%ad%Creset %C(yellow)###%d###%Creset %s";

# Matrix style
my $format = "%C(green)###%an###%Creset %C(bold)%C(green)%h%Creset %C(green)%ad%Creset %C(bold)%C(green)###%d###%Creset %C(green)%s";
# $opts = "";   # For purists


######################################################################################################


# Format / filter branches and align fields
# Don't run with --graph by default, slow on large repos and messes up formatting.
open(IN, "git log --pretty=format:'$format' $opts --date=short @ARGV $extra |");
open(OUT,"| less -cRS");
binmode IN, ':encoding(UTF-8)';  binmode OUT, ':encoding(UTF-8)';

my $lines = 0;
while (my $str = <IN>)
{
    $lines++;
    if ($str !~ m/###/)  {  print OUT $str; next;  }

    my ($h, $author, $a, $branches, $b) = split(/###/, "$str");
    chomp($b);

    if ($branches)  {  $branches = format_branches($branches);  }

    # Just keep last name if author too long.
    if (length($author) > $author_max)  {  $author =~ s/.* //;  }

    # Highlight merges if running without --graph
    if (!real_length($h))
    {  if ($b =~ m/Merge pull request/)  {  $h = "* $h";  } else  {  $h = "  $h";  }  }
    
    my $n = $author_max - real_length($author);
    my $str = sprintf("$h%s$author$a$branches", " " x $n);

    my $n = $width - real_length($str);
    printf OUT ("$str%s$b\n", " " x $n);
}

