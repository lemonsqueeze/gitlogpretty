#!/usr/bin/perl
# git log pretty formatting, one commit per line
#
# Usage: gitlogpretty [options] [git options]
#             --myselect    select branch to display
#             --full        don't stop at first 200 commits
#             --remote      show remote branches
#             --all         git log --all + show remote branches

my $max = 200;
my $limit = "-n $max";
my $extra = "";
my $hide_remote = 1;
my $width = 59;


# cmdline options
for (; @ARGV; shift(@ARGV)) {
    if ($ARGV[0] eq "--myselect" ) {
	my $cmd = 'myselect $(git branch | sed -e "s/\*//")';
	$extra .= " " . `bash -c '$cmd' `;
	($extra) || exit 0;
	next;
    }

    if ($ARGV[0] eq "--full")    {  $limit = ""; next;  }
    if ($ARGV[0] eq "--remote")  {  $hide_remote = 0; next;  }
    if ($ARGV[0] eq "--all")     {  $hide_remote = 0; $width = 79; $extra .= " --all"; next;  }
    
    last;   # Unrecognized options, pass to git
}


# String length without ansi color codes
sub real_length
{
    my ($s) = @_;
    $s =~ s/\e\[[^m]*m//g;
    return length($s);
}


# Hide remote branches if needed 
# Display branches and tags as "(branches) <tags>"
sub format_branches
{ 
    my ($branches) = @_;
    my @branches; my @tags;

    # Split tags and branches
    $branches =~ s|^ \((.*)\)|$1|;   # remove surrounding ()
    foreach my $b (split(/, /, $branches))  {
        if ($b =~ m/^tag: (.*)/)  {  push(@tags, $1);  }
        else                      {  push(@branches, $b);  }
    }

    # Hide remote branches
    if ($hide_remote)  {  @branches = grep(!/\//, @branches);  }

    $branches = "";
    if (@branches) { $branches =  sprintf(" (%s)", join(", ", @branches)); }
    if (@tags)     { $branches .= sprintf(" <%s>", join(", ", @tags)); }
    return $branches;
}


######################################################################################################
# Styles
# Note: '###' = field separator for us

# Show colored ascii-art for branches ?
my $opts = "--color";


# No colors
#my $format = "[%an] %h %ad% ###%d### %s";

# Matrix style
my $format = "%C(green)[%an]%Creset %C(bold)%C(green)%h%Creset %C(green)%ad%Creset %C(bold)%C(green)###%d###%Creset %C(green)%s";
# $opts = "";   # For purists

# Italian style
#my $format = "[%an] %C(red)%h%Creset %C(green)%ad%Creset %C(yellow)###%d###%Creset %s";

# Lemon style
#my $format = "%C(yellow)[%an]%Creset %C(white)%h%Creset %C(white)%ad%Creset %C(yellow)###%d###%Creset %s";


######################################################################################################


# Format / filter branches and align fields
open(IN, "git log $limit --pretty=format:'$format' $opts --graph --date=short @ARGV $extra |");
open(OUT,"| less -cRS");

my $lines = 0;
foreach my $str (<IN>)
{
    $lines++;
    if ($str !~ m/###/)  {  print OUT $str; next;  }

    my ($a, $branches, $b) = split(/###/, "$str");
    chomp($b);

    if ($branches)  {  $branches = format_branches($branches);  }

    my $n = $width - real_length("$a$branches");
    printf OUT ("%s%s%s\n", "$a$branches", " " x $n, $b); 
}

if ($limit && $lines >= $max)  {  print OUT "...\n"; }
